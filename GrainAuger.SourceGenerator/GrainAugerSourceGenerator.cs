using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis.Text;

namespace GrainAuger.SourceGenerator;

[Generator]
public class GrainAugerSourceGenerator : IIncrementalGenerator
{
    private const string AttributeSourceCode = $$"""
        // <auto-generated/>
        #nullable enable
        
        public class AugerJobConfigurationAttribute : System.Attribute
        {
            public string JobName { get; }
            public string JobDescription { get; }
            public string JobType { get; }
            public string JobVersion { get; }
            
            public AugerJobConfigurationAttribute(
                string jobName,
                string jobDescription,
                string jobType,
                string jobVersion
                )
            {
                JobName = jobName;
                JobDescription = jobDescription;
                JobType = jobType;
                JobVersion = jobVersion;
            }
        }
        """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "AugerJobConfigurationAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));
        
        // Filter the classes that implement IAugerJobConfiguration
        context.SyntaxProvider
            .CreateSyntaxProvider((node, token) =>
                {
                    if (node is not ClassDeclarationSyntax classDeclaration)
                    {
                        return false;
                    }

                    return classDeclaration.BaseList?.Types.Any(x =>
                        x.Type.ToString() == "IAugerJobConfiguration") == true;
                },
                (generatorContext, token) =>
                {
                    var classDeclaration = (ClassDeclarationSyntax)generatorContext.Node;
                    var semanticModel = generatorContext.SemanticModel;
                    var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration, token);

                    var namespaceName = classSymbol?.ContainingNamespace.ToDisplayString();

                    return (classDeclaration, namespaceName, semanticModel);
                });
    }

    private void GenerateGrain(SourceProductionContext context, Compilation compilation)
    {
        var outputStreamName = "GrainAuger_ExpiredCardDetector_Output";
        var namespaceName = "GrainAuger_vXXX_EntryPoint_Output";
        var grainKeyType = "String";
        var inputType = "CardTransaction";
        
        List<string> privateFields = new();
        List<string> constructorParameters = new();
        List<string> constructorAssignments = new();
        
        var code = $$"""
        // <auto-generated/>
        using GrainAuger.Core;
        using GrainAuger.Abstractions;
                
        namespace ${namespaceName};
        
        [ImplicitStreamSubscription("{{outputStreamName}}")]
        public class {{outputStreamName}}
            : Grain,
            IGrainWith{{grainKeyType}}Key,
            IAsyncObserver<{{inputType}}>
        {
            // Dependencies
            {{string.Join("/r/n", privateFields)}}
        
            public {{outputStreamName}}(
                {{string.Join(", ", constructorParameters)}}
                )
            {
                IGrainContext grainContext = new GrainContext(RegisterTimer);
                {{string.Join("/r/n", constructorAssignments)}}
            }
            
            public override async Task OnActivateAsync(CancellationToken cancellationToken)
            {
                await base.OnActivateAsync(cancellationToken);
                
            }
            
            public override async Task OnNextAsync({{inputType}} item, StreamSequenceToken token = null)
            {
                // Process the item
            }
            
            public override Task OnCompletedAsync()
            {
                return Task.CompletedTask;
            }
            
            public override Task OnErrorAsync(Exception ex)
            {
                return Task.CompletedTask;
            }
        }
        """;
        
        context.AddSource($"{outputStreamName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}
