using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;
using System.Threading;
using GrainAuger.Abstractions;
using Microsoft.CodeAnalysis.Text;

namespace GrainAuger.SourceGenerator;

[Generator]
public class GrainAugerSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter the methods that use AugerJobConfigurationAttribute
        var methodProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (syntaxNode, _) => syntaxNode is MethodDeclarationSyntax,
                GetMethodDeclarationForSourceGen)
            .Where(t => t is { jobConfigurationAttributeFound: true, syntax: not null })
            .Select((t, _) => t.syntax);
        
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(methodProvider.Collect()),
            (ctx, t) => GenerateGrains(ctx, t.Left, t.Right));
    }

    private (MethodDeclarationSyntax syntax, bool jobConfigurationAttributeFound)
        GetMethodDeclarationForSourceGen(GeneratorSyntaxContext context, CancellationToken token)
    {
        var methodDeclarationSyntax = (MethodDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in methodDeclarationSyntax.AttributeLists)    
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue;
                }
                
                var attributeName = attributeSymbol.ContainingType.ToDisplayString();
                
                if (attributeName == "GrainAuger.Abstractions.AugerJobConfigurationAttribute")
                {
                    return (methodDeclarationSyntax, true);
                }
            }
        }

        return (methodDeclarationSyntax, false);
    }

    private void GenerateGrains(SourceProductionContext context, Compilation compilation,
        ImmutableArray<MethodDeclarationSyntax> methodDeclarations)
    {
        foreach (var methodDeclaration in methodDeclarations)
        {
            GenerateGrain(context, compilation, methodDeclaration);
        }
    }

    private void GenerateGrain(SourceProductionContext context, Compilation compilation,
        MethodDeclarationSyntax methodDeclaration)
    {
        var semanticModel = compilation.GetSemanticModel(methodDeclaration.SyntaxTree);
        
        if (semanticModel.GetDeclaredSymbol(methodDeclaration) is not IMethodSymbol methodSymbol)
        {
            return;
        }
        
        var invocations = methodDeclaration.DescendantNodes()
            .OfType<InvocationExpressionSyntax>();

        Dictionary<string, List<string>> dag = new();
        
        // create a call graph from invocations, I want to get variable names
        foreach (var invocation in invocations)
        {
            var symbol = semanticModel.GetSymbolInfo(invocation).Symbol;
            if (symbol is not IMethodSymbol method)
            {
                continue;
            }

            var variableName = invocation.Ancestors().OfType<VariableDeclaratorSyntax>().FirstOrDefault()?.Identifier.Text;
            if (variableName == null)
            {
                continue;
            }
            
            // get information about the generic types inside <> of the method
            var genericTypes = method.TypeArguments.Select(t => t.Name);
            
            // get the information about constructors of the generic types
            var constructors = genericTypes.Select(t => semanticModel.Compilation.GetTypeByMetadataName(t)?.Constructors);

            var calledMethodName = method.Name;
            if (!dag.ContainsKey(variableName))
            {
                dag[variableName] = new List<string>();
            }

            dag[variableName].Add(calledMethodName);
        }
        
        
        // create comment of the dag
        var dagComment = string.Join("\n", dag.Select(kvp => $"{kvp.Key}: {string.Join(", ", kvp.Value)}"));
        
        var namespaceName = GetNamespaceName(methodSymbol);
        var attributes = methodSymbol.GetAttributes();
        // find one attribute with the name AugerJobConfigurationAttribute
        var attribute = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "AugerJobConfigurationAttribute");
        // get the job name property value from the attribute
        var jobName = GetJobNameFromAttribute(methodSymbol);
        
        var code = $$"""
        // <auto-generated/>
        using Orleans.Runtime;
        using Orleans.Streams;
        using GrainAuger.Core;
                
        namespace {{namespaceName}};
        
        /*
        {{dagComment}}
        */
        
        """;
        
        context.AddSource($"{jobName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }
    
    private static string GetNamespaceName(ISymbol methodSymbol)
    {
        var namespaceName = methodSymbol.ContainingNamespace.ToDisplayString();
        return namespaceName;
    }
    
    private static string GetJobNameFromAttribute(ISymbol methodSymbol)
    {
        var attributes = methodSymbol.GetAttributes();
        var attribute = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "AugerJobConfigurationAttribute");
        // it can either be keyed by the name or by the index (0)
        if (attribute?.NamedArguments.FirstOrDefault(a => a.Key == "JobName").Value.Value is string jobName)
        {
            return jobName;
        }
        
        if (attribute?.ConstructorArguments.FirstOrDefault().Value is string jobNameFromIndex)
        {
            return jobNameFromIndex;
        }
        
        return "UnknownJobName";
    }
}
