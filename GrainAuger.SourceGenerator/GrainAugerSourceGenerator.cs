using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis.Text;

namespace GrainAuger.SourceGenerator;

[Generator]
public class GrainAugerSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter the classes that implement IAugerJobConfiguration
        context.SyntaxProvider
            .CreateSyntaxProvider((node, token) =>
            {
                Console.WriteLine(node);
                if (node is not ClassDeclarationSyntax classDeclaration)
                {
                    return false;
                }
                
                return classDeclaration.BaseList?.Types.Any(x =>
                    x.Type.ToString() == "IAugerJobConfiguration") == true;
            }, 
                (generatorContext, _) =>
            {
                var classDeclaration = (ClassDeclarationSyntax)generatorContext.Node;
                var semanticModel = generatorContext.SemanticModel;
                var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);

                var namespaceName = classSymbol?.ContainingNamespace.ToDisplayString();

                return (classDeclaration, namespaceName);
            });
    }

    private void GenerateGrain(SourceProductionContext context, Compilation compilation)
    {
        var outputStreamName = "GrainAuger_ExpiredCardDetector_Output";
        var namespaceName = "GrainAuger_vXXX_EntryPoint_Output";
        var grainKeyType = "String";
        var inputType = "CardTransaction";
        
        var code = $$"""
        // <auto-generated/>
        
        namespace ${namespaceName};
        
        [ImplicitStreamSubscription("{{outputStreamName}}")]
        public class {{outputStreamName}}
            : Grain,
            IGrainWith{{grainKeyType}}Key,
            IAsyncObserver<{{inputType}}>
        {
            // Dependencies
        
            public {{outputStreamName}}(
                // Dependencies
                )
            {
                                
            }
            
            public override async Task OnActivateAsync(CancellationToken cancellationToken)
            {
                await base.OnActivateAsync(cancellationToken);
                
            }
            
            public override async Task OnNextAsync({{inputType}} item, StreamSequenceToken token = null)
            {
                // Process the item
            }
            
            public override Task OnCompletedAsync()
            {
                return Task.CompletedTask;
            }
            
            public override Task OnErrorAsync(Exception ex)
            {
                return Task.CompletedTask;
            }
        }
        """;
        
        context.AddSource($"{outputStreamName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }
}
